# 排序

## 理论优先级
  - 平均情况：基数 ~= 快速 ~= 归并 > 希尔 >> 插入 > 选择 ~= 冒泡
  - 最优情况：插入 ~= 冒泡 > 希尔 ~= 基数 ~= 快速 ~= 归并 >> 选择

## 稳定排序
  - 相同值的元素的相对顺序不改变
  - 插入、冒泡、归并、基数排序

## 非稳定排序
  - 相同值的元素的相对顺序可能改变
  - 选择、希尔、快速、堆排序

## 内部排序（只能在内存中进行）
  - 没用额外的存储空间
  - 插入、冒泡、选择、希尔、快速、堆排序

## 外部排序（可以使用硬盘）
  - 用了额外的存储空间
  - 归并、基数排序
  - 好处：可以对更大的数据量进行排序
  - 例子：归并排序在大数据场景下的应用
    - 问题：电脑内存2GB，对一个40GB的文件进行排序
    - 思路：
      - 分成20个文件，每次读取2GB，返回排序后的结果
      - 取20个排序后的文件的第一项，进行20个数据的排序
      - 将若干个20个数据的排序结果，依次拼接起来


---

## 1.选择排序
  - 时间复杂度：O(n^2)
  - 最优情况、最坏情况、平均情况的时间复杂度都是O(n^2)

---

## 2.插入排序
  - 时间复杂度：O(n^2)
  - 理论上讲比选择排序更快，但数组交换位置的操作过多（比数组遍历更耗时），故实际执行时间基本与选择排序相同，甚至略高
  - 最优情况：O(n) // 数据已经有序，只需遍历一层
    最坏情况：O(n^2)
    平均情况：O(n^2)

  - 优化（无监督的插入排序）
    增加了O(n)量级的数组交换操作，减少了O(n^2)量级的判断操作
---

## 3.希尔排序(分组插入排序)
  - 时间复杂度：O(nlogn) ～ O(n^2)
  - 最优情况：O(nlogn) // 数据已经有序，只需遍历一层
    最坏情况：O(n^2)
    平均情况：O(n^2)
  - 基于插入排序
  - 希尔排序的效率和【步长序列】紧密相关
    O(n2)希尔增量序列：n/2、n/4、n/8、n/16……
    O(n1.5)Hibbard增量序列：1、3、7…2k-1

---

## 4.冒泡排序
  - 时间复杂度：O(n^2)
  - 最优情况：O(n) // 数据已经有序，只需遍历一层
    最坏情况：O(n^2)
    平均情况：O(n^2)

---

## 5.快速排序
  - 时间复杂度：O(nlogn)
  - 最优情况：O(nlogn) // 每次分区操作后两边元素数量相等
    最坏情况：O(n^2) // 每次分区操作后一边为空，一边为所有元素
    平均情况：O(nlogn)
  - 分区情况的好坏直接取决于定义的基准值
  - 关键步骤：寻找基准值、分区、递归

---

## 6.归并排序
  - 时间复杂度：O(nlogn)
  - 最优情况：O(nlogn)
    最坏情况：O(nlogn)
    平均情况：O(nlogn)

---

## 7.基数排序
  - 时间复杂度：O(nlogm) - m指分成几轮，最优情况是把数字分成2部分，由2轮的基数分别进行排序
  - 最优情况：O(nlogm)
    最坏情况：O(nlogm)
    平均情况：O(nlogm)
  - 要点：相同数字，相对位置不变

---

## 8.堆排序
  - 时间复杂度：O()
  - 最优情况：O()
    最坏情况：O()
    平均情况：O()

---
